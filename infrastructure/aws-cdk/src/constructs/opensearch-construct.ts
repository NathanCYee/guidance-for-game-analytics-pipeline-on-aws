/**
 * Copyright 2023 Amazon.com, Inc. and its affiliates. All Rights Reserved.
 *
 * Licensed under the Amazon Software License (the 'License').
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *   http://aws.amazon.com/asl/
 *
 * or in the 'license' file accompanying this file. This file is distributed
 * on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

import * as yaml from "js-yaml";
import * as fs from "fs";

import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as path from "path";
import * as kinesis from "aws-cdk-lib/aws-kinesis";
import * as iam from "aws-cdk-lib/aws-iam";
import * as s3 from "aws-cdk-lib/aws-s3";
import { aws_opensearchserverless as opensearchserverless } from 'aws-cdk-lib';
import { aws_osis as osis } from 'aws-cdk-lib';
import * as logs from "aws-cdk-lib/aws-logs";

import { Aws, Fn } from "aws-cdk-lib";
import { GameAnalyticsPipelineConfig } from "../helpers/config-types";


/* eslint-disable @typescript-eslint/no-empty-interface */
export interface OpenSearchConstructProps extends cdk.StackProps {
  metricOutputStream: kinesis.IStream;
  config: GameAnalyticsPipelineConfig;
}

const defaultProps: Partial<OpenSearchConstructProps> = {};

/**
 * Deploys the OpenSearch Construct construct
 */
export class OpenSearchConstruct extends Construct {

  constructor(parent: Construct, name: string, props: OpenSearchConstructProps) {
    super(parent, name);

    /* eslint-disable @typescript-eslint/no-unused-vars */
    props = { ...defaultProps, ...props };

    const codePath = "../../business-logic";

    // dead letter queue for ingestion pipeline
    const dlqBucket = new s3.Bucket(this, "DeadLetterQueue", {
      objectOwnership: s3.ObjectOwnership.OBJECT_WRITER,
      removalPolicy: props.config.DEV_MODE
        ? cdk.RemovalPolicy.DESTROY
        : cdk.RemovalPolicy.RETAIN,
      autoDeleteObjects: props.config.DEV_MODE ? true : false,
      versioned: props.config.DEV_MODE ? false : true,
      encryption: s3.BucketEncryption.S3_MANAGED,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL
    });

    const collectionName = `${props.config.WORKLOAD_NAME}-metrics`.toLowerCase().substring(0, 28).replace(new RegExp('[^a-z0-9\-]+', 'g'), '');

    // serverless time series cluster
    const osCollection = new opensearchserverless.CfnCollection(this, 'GameAnalyticsCollection', {
      name: collectionName,
      description: `Serverless OpenSearch Collection for analyzing real-time timeseries game event data generated by the stack ${cdk.Aws.STACK_NAME}`,
      standbyReplicas: "ENABLED",
      type: 'TIMESERIES',
    });


    // defines opensearch encryption to be an AWS managed key
    const osEncryptionPolicyDefinition = {
      "Rules": [
        {
          "ResourceType": "collection",
          "Resource": [`collection/${collectionName}`]
        }
      ],
      "AWSOwnedKey": true
    }

    const osEncryptionPolicy = new opensearchserverless.CfnSecurityPolicy(this, 'GameAnalyticsCollectionEncryptionPolicy', {
      name: `gap-encryption-policy`,
      policy: JSON.stringify(osEncryptionPolicyDefinition),
      type: 'encryption'
    });
    osEncryptionPolicy.applyRemovalPolicy(cdk.RemovalPolicy.DESTROY);
    osCollection.addDependency(osEncryptionPolicy);

    // enable network access to collection
    const networkPolicyDefinition = [{
      "Rules": [
        {
          "Resource": [
            `collection/${collectionName}`
          ],
          "ResourceType": "collection"
        }
      ],
      "AllowFromPublic": true
    },
    ]

    const osNetworkPolicy = new opensearchserverless.CfnSecurityPolicy(this, 'GameAnalyticsCollectionNetworkPolicy', {
      name: `gap-network-policy`,
      policy: JSON.stringify(networkPolicyDefinition),
      type: 'network'
    });
    osNetworkPolicy.applyRemovalPolicy(cdk.RemovalPolicy.DESTROY);

    // enable data access to collection

    // game metric index

    // IAM admin security config for opensearch serverless

    // access policy for IAM Admin users

    // iam policy for ingestion pipeline

    // opensearch ingestion pipeline


    // load ingestion definition
    const pipelineName = `${props.config.WORKLOAD_NAME}-ingestion`.substring(0, 28).toLowerCase().replace(new RegExp('[^a-z0-9\-]+', 'g'), '');

    // ingestion iam role

    const ingestionRole = new iam.Role(this, "IngestionRole", {
      assumedBy: new iam.ServicePrincipal("osis-pipelines.amazonaws.com"),
      inlinePolicies: {
        pipelineAccessPermissions: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              actions: [
                "kinesis:DescribeStream",
                "kinesis:DescribeStreamSummary",
                "kinesis:GetRecords",
                "kinesis:GetShardIterator",
                "kinesis:ListShards",
                "kinesis:ListStreams",
                "kinesis:ListStreamConsumers",
                "kinesis:RegisterStreamConsumer"],
              resources: [props.metricOutputStream.streamArn],
              effect: iam.Effect.ALLOW,
              sid: "allowReadFromStream",
            }),
            new iam.PolicyStatement({
              actions: [
                "aoss:APIAccessAll",
                "aoss:BatchGetCollection"],
              resources: [osCollection.attrArn],
              effect: iam.Effect.ALLOW,
              sid: "allowAPIs",
            }),
            new iam.PolicyStatement({
              actions: [
                "aoss:CreateSecurityPolicy",
                "aoss:UpdateSecurityPolicy",
                "aoss:GetSecurityPolicy"],
              resources: ['*'],
              conditions: {
                "StringLike": {
                  "aoss:collection": [
                    osCollection.name
                  ]
                },
                "StringEquals": {
                  "aws:ResourceAccount": [
                    cdk.Aws.ACCOUNT_ID
                  ]
                }
              },
              effect: iam.Effect.ALLOW,
              sid: "allowSecurityPolicy",
            }),
            new iam.PolicyStatement({
              actions: ["s3:PutObject"],
              resources: [dlqBucket.arnForObjects("*")],
              effect: iam.Effect.ALLOW,
              sid: "s3Access",
            })
          ]
        })
      }
    });

    ingestionRole.addToPolicy(
      new iam.PolicyStatement({
        actions: [
          "kinesis:DescribeStream",
          "kinesis:DescribeStreamSummary",
          "kinesis:GetRecords",
          "kinesis:GetShardIterator",
          "kinesis:ListShards",
          "kinesis:ListStreams",
          "kinesis:ListStreamConsumers",
          "kinesis:RegisterStreamConsumer"],
        resources: [props.metricOutputStream.streamArn],
        effect: iam.Effect.ALLOW,
        sid: "allowReadFromStream",
      })
    );

    const unformattedIngestionDefinition = fs.readFileSync(`${codePath}/opensearch-ingestion/ingestion-definition.yml`, "utf8")

    const formattedIngestionDefinition = cdk.Fn.sub(unformattedIngestionDefinition, {
      pipeline_name: pipelineName,
      stream_name: props.metricOutputStream.streamName,
      host_name: osCollection.attrCollectionEndpoint,
      network_policy_name: osNetworkPolicy.name,
      role: ingestionRole.roleArn,
      dlq_bucket_name: dlqBucket.bucketName
    })

    const ingestionLogGroup = new logs.LogGroup(this, "IngestionLogGroup", {
      logGroupName: `/aws/vendedlogs/OpenSearchIngestion/${pipelineName}/audit-logs`,
      retention: props.config.CLOUDWATCH_RETENTION_DAYS,
      removalPolicy: cdk.RemovalPolicy.DESTROY
    });

    const ingestionPipeline = new osis.CfnPipeline(this, "GapIngestionPipeline", {
      minUnits: 2,
      maxUnits: 4,
      pipelineConfigurationBody: formattedIngestionDefinition,
      pipelineName: pipelineName,
      logPublishingOptions: {
        cloudWatchLogDestination: {
          logGroup: ingestionLogGroup.logGroupName
        },
        isLoggingEnabled: true
      },
    })


    // network config for ingestion pipeline

    // access policy for ingestion pipeline

  }
}
